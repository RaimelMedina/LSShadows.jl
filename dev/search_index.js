var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LSShadows","category":"page"},{"location":"#LSShadows","page":"Home","title":"LSShadows","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LSShadows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LSShadows]","category":"page"},{"location":"#LSShadows.UnitaryCircuit","page":"Home","title":"LSShadows.UnitaryCircuit","text":"RandomCircuit object. The choice of single-qubit and multi-qubit gates that conform a layer is passed as an argument. \n\nArguments\n\nN::Int: Number of qubits\np::Int: Circuit depth\n\n\n\n\n\n","category":"type"},{"location":"#LSShadows.classical_snapshot!-Tuple{Matrix{ComplexF64}, Matrix{ComplexF64}, Vector{Float64}, YaoArrayRegister.ArrayReg}","page":"Home","title":"LSShadows.classical_snapshot!","text":"classical_snapshot!(M_inverse::Array{ComplexF64, 2}, partial_tr::Array{ComplexF64, 2}, reconst_coefficient::Vector{Float64}, ρ_unknown::ArrayReg; threaded=false)\n\nConstruct the classical snapshot of an unknown quantum state ρ_unknown. For this, given the reconstruction coefficient it returns sum_A r_A sigma_A where r_A is the A-th component of the reconstruction coefficient and  sigma_A is the embeded reduced density matrix of the state sigma on region A.  \n\nArguments\n\nM_inverse: Pre-allocated matrix to store the result.\npartial_tr: Pre-allocated matrix to store the partial trace embedding.\nreconst_coefficient: Vector of Float64 representing the reconstruction coefficients.\nρ_unknown: Unknown quantum state as an ArrayReg.\nthreaded: Optional argument with default value of false, which determines if the function should be run in a multi-threaded mode.\n\nReturns\n\nNone. The function updates the M_inverse matrix in-place.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.construct_unitary-Tuple{UnitaryCircuit}","page":"Home","title":"LSShadows.construct_unitary","text":"construct_unitary(f::UnitaryCircuit; val=Val(:XZXCnot))\n\nReturns the unitary operator representing the N-qubit and depth p unitary circuit with the choice of layer given by the parameter type\n\nArguments\n\nf::RandomCircuit: UnitaryCircuit object\n\nOptional arguments\n\nval: By default equal to Val(:XZXCnot). Other options are Val(:ZZX) corresponding to the Floquet Ising Circuit and Val(:OnsiteHaar) for a local circuit composed of tensor products of Haar-random single qubit unitaries. \n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.entanglement_feature-Tuple{YaoArrayRegister.ArrayReg, Any}","page":"Home","title":"LSShadows.entanglement_feature","text":"entanglement_feature(ψ::ArrayReg, r)\n\nCalculate the entanglement feature for a given quantum state ψ and the register r. If the length of r is 0 or equal to the number of qubits in ψ, return 1.0. Otherwise, compute the purity of the density matrix for the specified register.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.entanglement_feature_page-Tuple{Int64, Vector{Int64}}","page":"Home","title":"LSShadows.entanglement_feature_page","text":"entanglement_feature_page(n::Int, rA::Vector{Int64})\n\nCalculate the entanglement feature associated with an n-qubit Haar random state.  rA corresponds to the qubits to be kept. \n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.entanglement_feature_vector-Tuple{YaoArrayRegister.ArrayReg, Vector{Vector{Int64}}}","page":"Home","title":"LSShadows.entanglement_feature_vector","text":"entanglement_feature_vector(ψ::ArrayReg, reg::Vector{Vector{Int64}})\n\nCompute the entanglement feature vector for a given quantum state ψ and a vector of registers reg. The entanglement feature vector is a vector containing the entanglement features for each register in reg.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.estimate_fidelity-Tuple{YaoArrayRegister.ArrayReg, Vector{Float64}, Vector}","page":"Home","title":"LSShadows.estimate_fidelity","text":"estimate_fidelity(rho::ArrayReg, rA::Vector{Float64}, ensemble::Vector; threaded=false)\n\nEstimate the fidelity between a given quantum state rho and an the reconstructed state.\n\nArguments\n\nrho: Quantum state as an ArrayReg.\nrA: Vector of Float64 representing the reconstruction coefficients.\nensemble: Vector of quantum states.\nthreaded: Optional argument with default value of false, which determines if the function should be run in a multi-threaded mode.\n\nReturns\n\nFidelity estimate as a Float64.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.onsite_haar_circuit-Tuple{UnitaryCircuit}","page":"Home","title":"LSShadows.onsite_haar_circuit","text":"onsite_haar_circuit(f::UnitaryCircuit)\n\nCreate an OnsiteHaar circuit, that is U = otimes_i=1^N u_i where the single qubit unitaries u_i are drawn from the Haar distribution. \n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.partial_tr_embedding!-Tuple{Matrix{ComplexF64}, YaoArrayRegister.ArrayReg, Vector{Int64}}","page":"Home","title":"LSShadows.partial_tr_embedding!","text":"partial_tr_embedding!(partial_tr::Array{ComplexF64, 2}, ψ0::ArrayReg, reg::Vector{Int64})\n\nCompute the reduced density matrix rho_A of a given quantum state ψ0 in the region reg. After that, it embeds the reduced density matrix back into the full hilbert space by constructing \n\nrho_A otimes mathbbId_barA\n\nThe results are stored in a pre-allocated array partial_tr.\n\nArguments\n\npartial_tr: Pre-allocated matrix to store the result.\nψ0: Quantum state as an ArrayReg.\nreg: Vector of Int64 representing the qubits to keep.\n\nReturns\n\nNone. The function updates the partial_tr matrix in-place.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.purity-Tuple{YaoAPI.DensityMatrix}","page":"Home","title":"LSShadows.purity","text":"purity(rho::DensityMatrix)\n\nCalculate the purity of a given density matrix rho. The purity is defined as the trace of the squared density matrix.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.reconstruction_coefficient-Tuple{Vector{Float64}}","page":"Home","title":"LSShadows.reconstruction_coefficient","text":"reconstruction_coefficient(WEσ::Vector{Float64}; d=2)\n\nCalculate the reconstruction coefficient for a given vector of entanglement features WEσ. \n\nArguments\n\nWEσ: Vector of entanglement features.\nd: Optional argument with default value of 2, representing the dimension of the underlying quantum system.\n\nReturns\n\nReconstruction coefficient as a vector of Float64.\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.xzxcnot_circuit-Tuple{UnitaryCircuit}","page":"Home","title":"LSShadows.xzxcnot_circuit","text":"xzxcnot_circuit(f::UnitaryCircuit)\n\nCreate an XZXCnot circuit compossed of Rx-Rz-Rx-Cnot gates with parameter to be dispatched. Here periodic boundary conditions are used\n\n\n\n\n\n","category":"method"},{"location":"#LSShadows.zzx_circuit-Tuple{UnitaryCircuit}","page":"Home","title":"LSShadows.zzx_circuit","text":"zzx_circuit(f::UnitaryCircuit)\n\nCreates a zzx_circuit compossed of Rz-Rzz-Rx gates with parameter to be dispatched. Here periodic boundary conditions are used\n\n\n\n\n\n","category":"method"}]
}
